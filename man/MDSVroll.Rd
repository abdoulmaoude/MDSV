% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MDSVroll.R
\name{MDSVroll}
\alias{MDSVroll}
\title{MDSV Rolling estimates, volatility forecast and backtesting}
\usage{
MDSVroll(
  N,
  K,
  data,
  ModelType = 0,
  LEVIER = FALSE,
  n.ahead = 1,
  n.bootpred = 10000,
  forecast.length = 500,
  refit.every = 25,
  refit.window = "recursive",
  window.size = NULL,
  calculate.VaR = TRUE,
  VaR.alpha = c(0.01, 0.05),
  cluster = NULL,
  rseed = NA,
  ...
)
}
\arguments{
\item{N}{An integer designing the number of components for the MDSV process}

\item{K}{An integer designing the number of states of each MDSV process component}

\item{data}{A univariate or bivariate data matrix. Can only be a matrix of 1 or 2 columns. If data has 2 columns, the first one has to be the log-returns and the second the realized variances.}

\item{ModelType}{An integer designing the type of model to be fit. \eqn{0} for univariate log-returns, \eqn{1} for univariate realized variances and \eqn{2} for joint log-return and realized variances.}

\item{LEVIER}{if \code{TRUE}, estime the MDSV model with leverage.}

\item{n.ahead}{An integer designing the forecast horizon.}

\item{n.bootpred}{An integer designing the number of simulation based re-fits the model. Not relevant for one horizon forecast or for non-leverage type model.}

\item{forecast.length}{An integer designing the length of the total forecast for which out of sample data from the dataset will be used for testing.}

\item{refit.every}{Determines every how many periods the model is re-estimated.}

\item{refit.window}{Whether the refit is done on an expanding window including all the previous data or a moving window where all previous 
data is used for the first estimation and then moved by a length equal to refit.every (unless the window.size option is used instead).}

\item{window.size}{If not NULL, determines the size of the moving window in the rolling estimation, which also determines the first point used.}

\item{calculate.VaR}{Whether to calculate forecast Value at Risk during the estimation.}

\item{VaR.alpha}{The Value at Risk tail level to calculate.}

\item{cluster}{A cluster object created by calling makeCluster from the parallel package. If it is not NULL, then this will be used for parallel estimation of the refits (remember to stop the cluster on completion).}

\item{rseed}{An integer use to initialize the random number generator for the resampling with replacement method (if not supplied take randomly).}

\item{...}{Further arguments passed to or from other methods.}
}
\value{
A list consisting of:
\itemize{
    \item N : number of components for the MDSV process.
    \item K : number of states of each MDSV process component.
    \item ModelType : type of models fitted.
    \item LEVIER : wheter the fit take the leverage effect into account or not.
    \item n.ahead : integer designing the forecast horizon.
    \item forecast.length : length of the total forecast for which out of sample data from the dataset will be used for testing.
    \item refit.every : Determines every how many periods the model is re-estimated.
    \item refit.window : Whether the refit is done on an expanding window including all the previous data or a moving window where all previous 
data is used for the first estimation and then moved by a length equal to refit.every (unless the window.size option is used instead).
    \item window.size : If not NULL, determines the size of the moving window in the rolling estimation, which also determines the first point used.
    \item calculate.VaR : Whether to calculate forecast Value at Risk during the estimation.
    \item VaR.alpha : The Value at Risk tail level to calculate.
    \item cluster : A cluster object created by calling makeCluster from the parallel package.
    \item data : data use for the fitting.
    \item dates : vector or names of data designing the dates.
    \item estimates : matrix of all the parameters estimates at each date.
    \item prevision : matrix of all prevision made a each date.
}
}
\description{
Method for creating rolling estimates and volatility forecast from MDSV models with option for refitting every n periods 
with parallel functionality. The rolling estimate can be done using univariate log-returns or realized variances or using joint log-returns and realized variances.
}
\details{
This is a wrapper function for creating rolling estimates and volatility forecasts using MDSV models, and optionally calculating the Value at Risk 
at specified levels. The argument refit.every determines every how many periods the model is re-estimated. Given a dataset of length n, 
it is possible to set how many periods from the end to use for out of sample forecasting (using the forecast.length option). 
For rolling 1-ahead forecasts and forecasts without leverage effect, no bootstrap in done and then n.bootpred is not required.
However, the Value-at-Risk baskesting is done for 1-ahead forecasts. A very important part of the function is performed 
in \code{C++} through the \pkg{Rcpp} package. The leverage effect is taken into account according to the FHMV model 
(see Augustyniak et al., 2019). For the univariate realized variances forecasting, log-returns are required to add leverage effect.
When cluster is not NULL, the estimations and forecasting are perform with parallel functionalilty which  is entirely based 
on the \pkg{parallel} package, and it is up to the user to pass a cluster object, and then stop it once the routine is completed.
The \link[base]{class} of the output of this function is \code{MDSVroll}. This class has a \link[base]{summary}, \link[base]{print} and 
\link[base]{plot} \link[utils]{methods} to summarize, print and plot the results. See 
\code{\link{summary.MDSVroll}}, \code{\link{print.MDSVroll}} and \code{\link{plot.MDSVroll}} for more details.
}
\examples{
\dontrun{
# MDSV(N=2,K=3) without leverage on univariate log-returns S&P500
data(sp500)         # Data loading

N                <- 2            # Number of components
K                <- 3            # Number of states
ModelType        <- 0            # Univariate log-returns
LEVIER           <- FALSE        # No leverage effect
n.ahead          <- 100          # Forecast horizon
forecast.length  <- 756          # rolling forecast length
refit.every      <- 63           # Period to re-estimate the model
refit.window     <- "recursive"  # No leverage effect
calculate.VaR    <- TRUE
VaR.alpha        <- c(0.01, 0.05, 0.1)
cluster          <- parallel::makeCluster(parallel::detectCores()[1]-1)
rseed            <- 125

# rolling forecasts
out<-MDSVroll(N=N, K=K, data=sp500, ModelType=ModelType, LEVIER=LEVIER, n.ahead = n.ahead, 
            forecast.length = forecast.length, refit.every = refit.every, refit.window = refit.window, 
            window.size=NULL,calculate.VaR = calculate.VaR, VaR.alpha = VaR.alpha, cluster = cluster, rseed = rseed)
parallel::stopCluster(cluster)
# Summary
summary(out, VaR.test=TRUE, Loss.horizon = c(1,5,10,25,50,75,100), Loss.window = 756)
# plot
plot(out, plot.type=c("VaR","sigma","dens"))


# MDSV(N=3,K=3) with leverage on joint log-returns and realized variances NASDAQ
data(nasdaq)       # Data loading

# rolling forecasts
out<-MDSVroll(N=3, K=3, data=nasdaq, ModelType=2, LEVIER=TRUE, n.ahead = 10, forecast.length = 100, 
            refit.every = 25, refit.window = "recursive", window.size = 1000, 
            calculate.VaR = TRUE, VaR.alpha = c(0.01,0.05), cluster = NULL, rseed = NA)
# Summary
summary(out, VaR.test=TRUE, Loss.horizon = c(1,2,4,9), Loss.window = 50)

}

}
\references{
Augustyniak, M., Bauwens, L., & Dufays, A. (2019). A new approach to volatility modeling: the factorial hidden Markov volatility model. 
\emph{Journal of Business & Economic Statistics}, 37(4), 696-709. \url{https://doi.org/10.1080/07350015.2017.1415910}

JamesHamilton: D.(1994), time series analysis, 1994.
}
\seealso{
For fitting \code{\link{MDSVfit}}, filtering \code{\link{MDSVfilter}}, simulation \code{\link{MDSVsim}} and bootstrap forecasting \code{\link{MDSVboot}}.
}
